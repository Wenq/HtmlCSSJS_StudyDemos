1.作用域

2.变量提升: 变量与函数; 函数声明，函数表达式

-----------------------------------------
作用域 

词法作用域及其查找规则

块级作用域

变量提升  函数声明提升

var let const

20180704:
闭包： 可以阻止垃圾回收
对作用域的引用，叫闭包。

0705:
闭包

0706:
iife
循环和闭包
-------------------------------------------
0709:
iife创建了一个作用域，可以用来解决循环中执行逻辑，保证每次循环变量的值单独起作用，而不是最后变成一样的值。

模块模式 单例模式

模块模式2个特点：？？

现代的模块机制：？

0711:
未来的模块机制
export导出api
import、module倒入api，两者区别是什么？
模块的两个主要特征是什么？

动态作用域
-------------------------------------------
0712:
块作用域的替代方案
1.？
2.隐私／显示作用域
3. try/catch 性能问题

this词法
箭头函数
let self=this;

第二部分
this和对象原型
-------------------------------------------
0713:
js中，所有函数都是对象；

function foo(num) { console.log( "foo: " + num ); // 记录 foo 被调用的次数 foo.count++; }
具名函数中，函数内部通过函数名称就可以访问函数本身，this不指向函数本身，但有时指向函数的作用域；

还有一种传统的但是现在已经被弃用和批判的用法，是使用 arguments. callee 来引用当前正在运行的函数对象。

function foo(num) { console.log( "foo: " + num ); // 记录 foo 被调用的次数 // 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo this.count++; } foo.count = 0; var i; for (i=0; i<10; i++) { if (i > 5) { // 使用 call(..) 可以确保 this 指向函数对象 foo 本身 foo.call( foo, i ); } }
说明：使用‘函数.call’，可以强制 this 指向 foo 函数对象；
-------------------------------------------
0715:
this 在任何情况下都不指向函数的词法作用域。

this到底是什么?
this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调 用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。

第 2 章 this全面解析
调用栈（可用过浏览器js调试器或者代码中写debugger暂停）
调用位置

this绑定规则：
1.默认绑定：直接使用不带任何修饰的函数引用进行调用；如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined；
2.隐式绑定：当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。
3.显式绑定：JavaScript 提供的绝大多数函数以及你自 己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。eg:foo.call( obj ); //把obj作为foo的this传进去，进行显示绑定。 传入基本数据类型，如booll等会触发‘装箱’行为；‘硬绑定’；

通常来说你不应该在代码中混合使用 strict mode 和 non-strict mode。

-------------------------------------------
