1.作用域

2.变量提升: 变量与函数; 函数声明，函数表达式

-----------------------------------------
作用域 

词法作用域及其查找规则

块级作用域

变量提升  函数声明提升

var let const

-------------------------------------------
20180704:
闭包： 可以阻止垃圾回收
对作用域的引用，叫闭包。

0705:
闭包

-------------------------------------------
0706:
iife
循环和闭包

-------------------------------------------
0709:
iife创建了一个作用域，可以用来解决循环中执行逻辑，保证每次循环变量的值单独起作用，而不是最后变成一样的值。

模块模式 单例模式

模块模式2个特点：？？

现代的模块机制：？

-------------------------------------------
0711:
未来的模块机制
export导出api
import、module倒入api，两者区别是什么？
模块的两个主要特征是什么？

动态作用域

-------------------------------------------
0712:
块作用域的替代方案
1.？
2.隐私／显示作用域
3. try/catch 性能问题

this词法
箭头函数
let self=this;

第二部分
this和对象原型

-------------------------------------------
0713:
js中，所有函数都是对象；

function foo(num) { console.log( "foo: " + num ); // 记录 foo 被调用的次数 foo.count++; }
具名函数中，函数内部通过函数名称就可以访问函数本身，this不指向函数本身，但有时指向函数的作用域；

还有一种传统的但是现在已经被弃用和批判的用法，是使用 arguments. callee 来引用当前正在运行的函数对象。

function foo(num) { console.log( "foo: " + num ); // 记录 foo 被调用的次数 // 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo this.count++; } foo.count = 0; var i; for (i=0; i<10; i++) { if (i > 5) { // 使用 call(..) 可以确保 this 指向函数对象 foo 本身 foo.call( foo, i ); } }
说明：使用‘函数.call’，可以强制 this 指向 foo 函数对象；

-------------------------------------------
0715:
this 在任何情况下都不指向函数的词法作用域。

this到底是什么?
this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调 用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。

第 2 章 this全面解析
调用栈（可用过浏览器js调试器或者代码中写debugger暂停）
调用位置

this绑定规则：
1.默认绑定：直接使用不带任何修饰的函数引用进行调用；如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined；
2.隐式绑定：当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。
3.显式绑定：JavaScript 提供的绝大多数函数以及你自 己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。eg:foo.call( obj ); //把obj作为foo的this传进去，进行显示绑定。 传入基本数据类型，如booll等会触发‘装箱’行为；‘硬绑定’；

通常来说你不应该在代码中混合使用 strict mode 和 non-strict mode。

-------------------------------------------
0716：
3.显示绑定：硬绑定；API调用的“上下文”；
4.new绑定：包括内置对象函数（比如 Number(..)，详情请查看第 3 章）在内的所有函数都可 以用 new 来调用，这种函数调用被称为构造函数调用。
function foo(a) { this.a = a; } var bar = new foo(2); console.log( bar.a ); // 2   
使用new关键字，会使得函数内部的this就指向函数本身。

2.3 优先级
new绑定>显示绑定>隐式绑定>默认绑定
需要理解优先级的原因：如果某个调用位置可以应用多条规则该怎么办？为了 解决这个问题就必须给这些规则设定优先级，

javascript：柯里化的概念。

判断this：
判断顺序如下
1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 var bar = new foo()
2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 var bar = foo.call(obj2)
3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo()
4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 var bar = foo()

2.4 绑定例外
【该章节没有看，暂时跳过】

2.5 this词法：
箭头函数：不使用上面4种绑定规则中任意一种。

-------------------------------------------
0717:
[this词法]：
箭头函数的this= 根据外层函数或全局作用域来决定。会继承外层调用函数的this绑定；

[第3章 对象]：
定义对象：文字语法和构建对象； 一般使用文字语法｛key：value｝

6种主要类型：（简单基本类型） string number bool null undefined  object。

内置对象：（对象子类型）

-------------------------------------------
0720:
[内置对象]（对象子类型：）
String • Number • Boolean • Object • Function • Array • Date • RegExp • Error
推荐用字面形式创建一个对象(eg: var a = 'xxxx')，而非'new()'（即构造形式）方式。
调用a.length是隐式的将string转为了String类型，String类型才有相关属性和方法可以访问。
Function,Array等本身都是object类型。

js里‘null’用来判断是，等同于'false'.

【3.3 内容】：
存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度 来说就是引用）一样，指向这些值真正的存储位置。

.a 语法通 常被称为“属性访问”，["a"] 语法通常被称为“键访问”。

在对象中，属性名永远都是字符串。如果你使用 string（字面量）以外的其他值作为属性 名，那它首先会被转换为一个字符串。

【3.3.1 可计算属性名】：
ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名

【3.3.2 属性与方法】：暂不阅读
【3.3.3 数组】：暂不阅读

【3.3.4 复制对象】：
JavaScript 初学者最常见的问题之一就是如何复制一个对象。看起来应该有一个内置的 copy() 方法，是吧？实际上事情比你想象的更复杂，因为我们无法选择一个默认的复制算法。

我们应该判断它是浅复制还是深复制。

相比深复制，浅复制非常易懂并且问题要少得多，所以 ES6 定义了 Object.assign(..) 方 法来实现浅复制。

【3.3.5 属性描述符】：
 ES5 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属 性是否是只读。 但是从 ES5 开始，所有的属性都具备了属性描述符。
获取对象描述信息的方法：Object.getOwnPropertyDescriptor( myObject, "a" );

举例来说： var myObject = {}; Object.defineProperty( myObject, "a", { value: 2, writable: true, configurable: true, enumerable: true } ); myObject.a; // 2 我们使用 defineProperty(..) 给 myObject 添加了一个普通的属性并显式指定了一些特性。 然而，一般来说你不会使用这种方式，除非你想修改属性描述符。

【3.3.6 不变性】：
可让对象禁止修改(扩展....)

【3.3.7 [[Get]]】：暂不阅读
【3.3.8 [[Put]]】：暂不阅读
【3.3.9 Getter和Setter】：暂不阅读
 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法 应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏 函数，会在设置属性值时调用。
【3.3.10 存在性】：
判断对象是否有有个属性：myObject.hasOwnProperty( "a" ); 
另一种调用：：Object.prototype.hasOwnProperty. call(myObject,"a")

Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论它们是否可枚举。 in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。

【3.4 遍历】：
遍历对象属性；遍历对象值；
对象实现迭代器？？

许多人都以为“JavaScript 中万物都是对象”，这是错误的。
对象是 6 个（或者是 7 个，取 决于你的观点）基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同 的行为。

【 第4 章 混合对象“类”】：暂不阅读
js也与面向对象的几大特性：封装，继承，多态；
JavaScript 中不存在类；

【小结】：
类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。JavaScript 也有类 似的语法，但是和其他语言中的类完全不同。 类意味着复制。

总地来说，在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋 下更多的隐患。

【第 5 章 原型】：（重点！！！）
【5.1 [[Prototype]]】：
使用create创建对象，会将对象的prototype关联到特定对象上去；
objA.a来访问对象的属性a，在当前对象objA中没查找到属性a，就会沿着prototype链去查找；
{ a = 12; }:在一段代码段内给一个变量赋值，首先会去查找该变量是‘谁’，在当前作用域找不到，就会逐层往更上一层作用域去查找。

【5.1.1 Object.prototype】：
所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。

-------------------------------------------
0721:
【5.2 “类”】：
【5.2.1 “类”函数】
【5.2.2 “构造函数”】
【5.2.3 技术】

原型继承的机制！

-------------------------------------------
0722：
【5.3 （原型）继承】：
Bar.prototype = Object.create( Foo.prototype )。调用 Object.create(..) 会凭空创建一个“新”对象并把新对象内部的 [[Prototype]] 关联到你 指定的对象（本例中是 Foo.prototype）。

ES6 之前， 我们只能通过设置 .__proto__ 属性来实现，但是这个方法并不是标准并且无法兼容所有浏 览器。ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修 改关联。
// ES6 之前需要抛弃默认的 Bar.prototype Bar.ptototype = Object.create( Foo.prototype ); // ES6 开始可以直接修改现有的 Bar.prototype Object.setPrototypeOf( Bar.prototype, Foo.prototype );

【检查“类”关系】：
有对象 a，如何寻找对象 a 委托的对象（即祖先）？
a instanceof Foo; // true
上面是实力对象与函数，还有如下实例与实例的prototype比较：
非常简单：b 是否出现在 c 的 [[Prototype]] 链中？ b.isPrototypeOf( c );

可以直接获取一个对象的 [[Prototype]] 链。在 ES5 中，标准的方法是： Object.getPrototypeOf( a )

【5.4 对象关联】：
，[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他 对象。 通常来说，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就 会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的 引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。

【5.4.1 创建关联】：
var bar = Object.create( foo );

Object.create(null) 会 创 建 一 个 拥 有 空（ 或 者 说 null）[[Prototype]] 链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符（之前解释过）无法进行判断，因此总是会返回 false。 这些特殊的空 [[Prototype]] 对象通常被称作“字典”，它们完全不会受到原 型链的干扰，因此非常适合用来存储数据。

Object.create(..) 是在 ES5 中新增的函数。
-------------------------------------------

0723:
JavaScript 的 [[Prototype]] 机制和类不一样.
Object.create(..) 的第二个参数指定了需要添加到新对象中的属性名以及这些属性的属性.
第一个参数是：要关联到prototype的对象(函数).

【5.4.2 关联关系是备用】：
[[Prototype]] 的本质是什么？

在 ES6 中有一个被称为“代理”（Proxy）的高端功能，熟悉下？？？
委托是什么？ 通过prototype关联一个对象A，就可以在当前对象中访问对象A的相关属性/方法。

是委托设计模式是什么？

【5.5 小结】：
所有普通对象都有内置的 Object.prototype，指向原型链的顶端（比如说全局作用域），如 果在原型链中找不到指定的属性就会停止。toString()、valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。

关联两个对象最常用的方法是使用 new 关键词进行函数调用。
带 new 的函数调用 通常被称为“构造函数调用”。

JavaScript 中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。

对象之间的关系不是复制而是委托。

【第 6 章 行为委托】：
：[[Prototype]] 机制就是指对象中的一个内部链接引用 另一个对象。
【6.1.1 类理论】：用传统面向对象思想，创建基类，再创建子类从基类继承过来，在子类中重写父类某些方法。
【6.1.2 委托理论】：上面是传统的OO思想，下面用委托设计思想理解下=》
-------------------------------------------
