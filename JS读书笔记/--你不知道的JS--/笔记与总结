1.作用域

2.变量提升: 变量与函数; 函数声明，函数表达式

-----------------------------------------
作用域 

词法作用域及其查找规则

块级作用域

变量提升  函数声明提升

var let const

20180704:
闭包： 可以阻止垃圾回收
对作用域的引用，叫闭包。

0705:
闭包

0706:
iife
循环和闭包
-------------------------------------------
0709:
iife创建了一个作用域，可以用来解决循环中执行逻辑，保证每次循环变量的值单独起作用，而不是最后变成一样的值。

模块模式 单例模式

模块模式2个特点：？？

现代的模块机制：？

0711:
未来的模块机制
export导出api
import、module倒入api，两者区别是什么？
模块的两个主要特征是什么？

动态作用域
-------------------------------------------
0712:
块作用域的替代方案
1.？
2.隐私／显示作用域
3. try/catch 性能问题

this词法
箭头函数
let self=this;

第二部分
this和对象原型
-------------------------------------------
0713:
js中，所有函数都是对象；

function foo(num) { console.log( "foo: " + num ); // 记录 foo 被调用的次数 foo.count++; }
具名函数中，函数内部通过函数名称就可以访问函数本身，this不指向函数本身，但有时指向函数的作用域；

还有一种传统的但是现在已经被弃用和批判的用法，是使用 arguments. callee 来引用当前正在运行的函数对象。

function foo(num) { console.log( "foo: " + num ); // 记录 foo 被调用的次数 // 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo this.count++; } foo.count = 0; var i; for (i=0; i<10; i++) { if (i > 5) { // 使用 call(..) 可以确保 this 指向函数对象 foo 本身 foo.call( foo, i ); } }
说明：使用‘函数.call’，可以强制 this 指向 foo 函数对象；
-------------------------------------------
