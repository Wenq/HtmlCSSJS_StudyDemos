1.作用域

2.变量提升: 变量与函数; 函数声明，函数表达式

-----------------------------------------
作用域 

词法作用域及其查找规则

块级作用域

变量提升  函数声明提升

var let const

-------------------------------------------
20180704:
闭包： 可以阻止垃圾回收
对作用域的引用，叫闭包。

0705:
闭包

-------------------------------------------
0706:
iife
循环和闭包

-------------------------------------------
0709:
iife创建了一个作用域，可以用来解决循环中执行逻辑，保证每次循环变量的值单独起作用，而不是最后变成一样的值。

模块模式 单例模式

模块模式2个特点：？？

现代的模块机制：？

-------------------------------------------
0711:
未来的模块机制
export导出api
import、module倒入api，两者区别是什么？
模块的两个主要特征是什么？

动态作用域

-------------------------------------------
0712:
块作用域的替代方案
1.？
2.隐私／显示作用域
3. try/catch 性能问题

this词法
箭头函数
let self=this;

第二部分
this和对象原型

-------------------------------------------
0713:
js中，所有函数都是对象；

function foo(num) { console.log( "foo: " + num ); // 记录 foo 被调用的次数 foo.count++; }
具名函数中，函数内部通过函数名称就可以访问函数本身，this不指向函数本身，但有时指向函数的作用域；

还有一种传统的但是现在已经被弃用和批判的用法，是使用 arguments. callee 来引用当前正在运行的函数对象。

function foo(num) { console.log( "foo: " + num ); // 记录 foo 被调用的次数 // 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo this.count++; } foo.count = 0; var i; for (i=0; i<10; i++) { if (i > 5) { // 使用 call(..) 可以确保 this 指向函数对象 foo 本身 foo.call( foo, i ); } }
说明：使用‘函数.call’，可以强制 this 指向 foo 函数对象；

-------------------------------------------
0715:
this 在任何情况下都不指向函数的词法作用域。

this到底是什么?
this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调 用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。

第 2 章 this全面解析
调用栈（可用过浏览器js调试器或者代码中写debugger暂停）
调用位置

this绑定规则：
1.默认绑定：直接使用不带任何修饰的函数引用进行调用；如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，因此 this 会绑定 到 undefined；
2.隐式绑定：当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。
3.显式绑定：JavaScript 提供的绝大多数函数以及你自 己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。eg:foo.call( obj ); //把obj作为foo的this传进去，进行显示绑定。 传入基本数据类型，如booll等会触发‘装箱’行为；‘硬绑定’；

通常来说你不应该在代码中混合使用 strict mode 和 non-strict mode。

-------------------------------------------
0716：
3.显示绑定：硬绑定；API调用的“上下文”；
4.new绑定：包括内置对象函数（比如 Number(..)，详情请查看第 3 章）在内的所有函数都可 以用 new 来调用，这种函数调用被称为构造函数调用。
function foo(a) { this.a = a; } var bar = new foo(2); console.log( bar.a ); // 2   
使用new关键字，会使得函数内部的this就指向函数本身。

2.3 优先级
new绑定>显示绑定>隐式绑定>默认绑定
需要理解优先级的原因：如果某个调用位置可以应用多条规则该怎么办？为了 解决这个问题就必须给这些规则设定优先级，

javascript：柯里化的概念。

判断this：
判断顺序如下
1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 var bar = new foo()
2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 var bar = foo.call(obj2)
3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo()
4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 var bar = foo()

2.4 绑定例外
【该章节没有看，暂时跳过】

2.5 this词法：
箭头函数：不使用上面4种绑定规则中任意一种。

-------------------------------------------
0717:
[this词法]：
箭头函数的this= 根据外层函数或全局作用域来决定。会继承外层调用函数的this绑定；

[第3章 对象]：
定义对象：文字语法和构建对象； 一般使用文字语法｛key：value｝

6种主要类型：（简单基本类型） string number bool null undefined  object。

内置对象：（对象子类型）

-------------------------------------------
0720:
[内置对象]（对象子类型：）
String • Number • Boolean • Object • Function • Array • Date • RegExp • Error
推荐用字面形式创建一个对象(eg: var a = 'xxxx')，而非'new()'（即构造形式）方式。
调用a.length是隐式的将string转为了String类型，String类型才有相关属性和方法可以访问。
Function,Array等本身都是object类型。

js里‘null’用来判断是，等同于'false'.

【3.3 内容】：
存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度 来说就是引用）一样，指向这些值真正的存储位置。

.a 语法通 常被称为“属性访问”，["a"] 语法通常被称为“键访问”。

在对象中，属性名永远都是字符串。如果你使用 string（字面量）以外的其他值作为属性 名，那它首先会被转换为一个字符串。

【3.3.1 可计算属性名】：
ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名

【3.3.2 属性与方法】：暂不阅读
【3.3.3 数组】：暂不阅读

【3.3.4 复制对象】：
JavaScript 初学者最常见的问题之一就是如何复制一个对象。看起来应该有一个内置的 copy() 方法，是吧？实际上事情比你想象的更复杂，因为我们无法选择一个默认的复制算法。

我们应该判断它是浅复制还是深复制。

相比深复制，浅复制非常易懂并且问题要少得多，所以 ES6 定义了 Object.assign(..) 方 法来实现浅复制。

【3.3.5 属性描述符】：
 ES5 之前，JavaScript 语言本身并没有提供可以直接检测属性特性的方法，比如判断属 性是否是只读。 但是从 ES5 开始，所有的属性都具备了属性描述符。
获取对象描述信息的方法：Object.getOwnPropertyDescriptor( myObject, "a" );

举例来说： var myObject = {}; Object.defineProperty( myObject, "a", { value: 2, writable: true, configurable: true, enumerable: true } ); myObject.a; // 2 我们使用 defineProperty(..) 给 myObject 添加了一个普通的属性并显式指定了一些特性。 然而，一般来说你不会使用这种方式，除非你想修改属性描述符。

【3.3.6 不变性】：
可让对象禁止修改(扩展....)

【3.3.7 [[Get]]】：暂不阅读
【3.3.8 [[Put]]】：暂不阅读
【3.3.9 Getter和Setter】：暂不阅读
 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法 应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏 函数，会在设置属性值时调用。
【3.3.10 存在性】：
判断对象是否有有个属性：myObject.hasOwnProperty( "a" ); 
另一种调用：：Object.prototype.hasOwnProperty. call(myObject,"a")

Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论它们是否可枚举。 in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。

【3.4 遍历】：
遍历对象属性；遍历对象值；
对象实现迭代器？？

许多人都以为“JavaScript 中万物都是对象”，这是错误的。
对象是 6 个（或者是 7 个，取 决于你的观点）基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同 的行为。

【 第4 章 混合对象“类”】：暂不阅读
js也与面向对象的几大特性：封装，继承，多态；
JavaScript 中不存在类；

【小结】：
类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。JavaScript 也有类 似的语法，但是和其他语言中的类完全不同。 类意味着复制。

总地来说，在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋 下更多的隐患。

【第 5 章 原型】：（重点！！！）
【5.1 [[Prototype]]】：
使用create创建对象，会将对象的prototype关联到特定对象上去；
objA.a来访问对象的属性a，在当前对象objA中没查找到属性a，就会沿着prototype链去查找；
{ a = 12; }:在一段代码段内给一个变量赋值，首先会去查找该变量是‘谁’，在当前作用域找不到，就会逐层往更上一层作用域去查找。

【5.1.1 Object.prototype】：
所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。

-------------------------------------------
